;; we have a bunch of numbers generated by a process
;; the factors are also randomly generated

;; Reminds inductive logic programming

;; Does this mean we need to account for the transition probability of factor
;; creation?

(define (randintS a b)
  (+ a (sample-integerS (- b a))))

(define (randint a b)
  (+ a (sample-integer (- b a))))

;; different factors, different scope constructors
(define tf-eq
  (make-factor (lambda (x y) (norm-gauss-log-pdf 0 0.1 (- x y)))))

(define tf-offby
  (make-factor (lambda (n x y) (norm-gauss-log-pdf n 0.1 (abs (- x y))))))

(define (tf-offby1 x y) (tf-offby 1 x y))


(define (get-scope-name scope)
  (cond [(eq? bi-gram scope) 'bi-gram]
        [(eq? bi-gram-skip-1 scope) 'bi-gram-skip-1]
        [else 'error]))

(define (get-tf-name tf)
  (cond [(eq? tf-eq tf) 'eq]
        [(eq? tf-offby1 tf) 'tf-offby1]
        [else 'error]))

(define bi-gram-skip-1 (lambda (xs) (bi-gram-skip 1 xs)))

(for-each display (larj-mh-query-proposal-count 10000 1 100
;; (for-each display (mh-query 100 200
  (define res
    (let* ([num-elts 10]
           [elts (repeat num-elts (lambda () (if (flip) 0 1)))]
           [scope (if (flipS) bi-gram bi-gram-skip-1)]
           ;; [tf (if (flipS) tf-eq tf-offby1)]
           [tf tf-offby1]
           [void (map (lambda (vs) (apply tf vs)) (scope elts))]
           [which-tf (get-tf-name tf)]
           [which-scope (get-scope-name scope)])
      (list elts which-tf which-scope)))
  res
  true))

