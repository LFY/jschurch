;; using inc-prov / dec-prov primitives to implement transparent lists

;; transparent lists are ones that themselves contain annotated values, and
;; attempt to minimize the propagation of annotations to the values inside the
;; lists---e.g., tr-list-ref xs i has only provenance of the i-th element, not
;; the whole list as before.

(define xs1 (tr-list (flip) (flip) (flip)))
(define ys1 (tr-list (flip) (flip) (flip)))

(define id (lambda (x) x))

(begin
  (display '(the transparent list:))
  (display-prov xs1)
  (display '(the second element (depends only on one xrp)))
  (display-prov (tr-list-ref xs1 1))
  (display '(car and cdr work too))
  (display-prov (tr-car xs1))
  (display-prov (tr-cdr xs1))
  (display '(so does cons))
  (display-prov (tr-cons (flip) xs1))
  (display '(so does this version of map))
  (display-prov (tr-map (lambda (x) (not x)) xs1))
  (display '(vs normal map:))
  (display-prov (map (lambda (x) (not (dec-prov x))) xs1))
  (display '(same for filter:))
  (display-prov (filter (lambda (x) (dec-prov x)) xs1))
  (display-prov (tr-filter id xs1))
  (display '(Nesting also works---the dependency information is preserved through zip patterns))
  (display-prov (tr-zip xs1 ys1))
  (display-prov (tr-zipN (tr-list xs1 ys1)))
  (display-prov (tr-zip3 xs1 ys1 xs1))
  (display-prov (tr-list xs1 ys1))
  'done)

