;; This file contains all of the mcmc code that doesn't mess with
;; states, i.e., all of the stuff at the level of kernels and above.

;; what must be provided elsewhere:
;; counterfactual-update
;; structure handling: mcmc-state->xrp-draws, mcmc-state->score, mcmc-state->query-value.

;; NOTE: since these are church procedures, the xrp-list will accumulate draws due to accept/reject decisions and proposals. will this cause bad slowdown?

;; kernels (mcmc transition distributions) and proposal distributions

(define (log-flip* . w)
  (if (null? w)
      (< (random-real) 0.5)
      (< (log (random-real)) (car w))))

(define (uniform-draw* lst)
  (if (null? lst)
      '() 
      (list-ref lst (random-integer (length lst)))))

(define (proposable-xrps state proposable?)
  (filter proposable? (addbox->values (mcmc-state->xrp-draws state))))

(define (selective-proposal-distribution state normal-form-proc proposable?)
  (if (addbox-empty? (mcmc-state->xrp-draws state))
      (list 0.0 state) ;; if no xrps have been drawn (eg all randomness in q-e) make trivial proposal. (still have to update..??)
      (let ((proposal-xrps (proposable-xrps state proposable?))) ;;fileter out proposable xrps to proposal-xrps
        (if (null? proposal-xrps)
            (list 0.0 state)
            (let* ((chosen-xrp (uniform-draw* proposal-xrps))
                   (ret1 ((xrp-draw-proposer chosen-xrp) state))
                   (proposed-val (first ret1))
                   (proposal-fw-score (second ret1))
                   (proposal-bw-score (third ret1))
                   (ret2 (counterfactual-update state normal-form-proc (pair chosen-xrp proposed-val)))
                   (proposal-state (first ret2))
                   (cd-bw/fw (second ret2))
                   (ind-fw (- (log (length proposal-xrps))))
                   (ind-bw (- (log (length (proposable-xrps proposal-state proposable?)))))
                   ;;(dummy (for-each display (list "ind-fw " ind-fw "  ind-bw " ind-bw "  cd-bw/fw " cd-bw/fw  " proposal-bw-score  " proposal-bw-score " proposal-fw-score  " proposal-fw-score "\n")))
                   )
              (list (+ (- proposal-bw-score proposal-fw-score) cd-bw/fw (- ind-bw ind-fw)) proposal-state))))))

(define (basic-proposal-distribution state normal-form-proc)
  (selective-proposal-distribution state normal-form-proc (lambda (xrp-draw) true)))

(define (rejection-initializer normal-form-proc)
  (let loop ()
    (let ((rejectioninit-proposal-state (first (counterfactual-update (make-initial-mcmc-state) normal-form-proc))))
      (if (= minus-infinity (mcmc-state->score rejectioninit-proposal-state))
          (loop) ;;don't care about bw/fw for init.
          rejectioninit-proposal-state))))

(define verbose-init #f)

;; initialize using rejection on highest temp
;; then for each temp from high to low:
;; - rescore
;; - do rejuvenation steps
;; finally, check whether p != 0 (if 0, restart at top)
(define (annealing-initializer rej-steps temps:low->high temps->nfqp . rejuv-kernel-builder)
  (let* ([rejuv-kernel-builder (if (null? rejuv-kernel-builder) (lambda (nfqp) (basic-repeat-kernel rej-steps nfqp)) (first rejuv-kernel-builder))]
         [temps:high->low (reverse temps:low->high)]
         [normal-form-proc (apply temps->nfqp (first temps:high->low))]
         [initial-state (begin (reset-store-xrp-draws)
                               (rejection-initializer normal-form-proc))])
    (let next-temp ([temps (rest temps:high->low)]
                    [mcmc-state initial-state])
      (if (= minus-infinity (mcmc-state->score mcmc-state))
          (begin
            (when verbose-init
                  (display "annealing-initializer: failed, restarting at top ...\n"))
            (annealing-initializer rej-steps temps:low->high temps->nfqp rejuv-kernel-builder))
          (if (null? temps)
              (begin
                (when verbose-init
                      (display "annealing-initializer: succeeded!\n"))
                mcmc-state)
              (begin
                (when verbose-init
                      (for-each display
                                (list "annealing-initializer:\n"
                                      "  temps remaining: " (length temps)
                                      "\n  current temp: " (first temps)
                                        ;"\n  current val: " (untapify (mcmc-state->query-value mcmc-state))
                                      "\n")))
                (let* ([nfqp (apply temps->nfqp (first temps))]
                       [rescored-state (first (counterfactual-update mcmc-state nfqp))]
                       [kernel (rejuv-kernel-builder nfqp)]
                       [rej-state (kernel rescored-state)])
                  (next-temp (rest temps)
                             rej-state))))))))


;;basic MH kernel
;;the proposal distribution takes a current state and returns a list of bw-fw score and proposed state.
;;the scorer takes a state and returns the score.

(define (make-mh-kernel proposal-distribution scorer)
  (lambda (state)
    (let* ((ret (proposal-distribution state))
           (bw/fw (first ret))
           (proposal-state (second ret)) 
           (old-p (scorer state))
           (new-p (scorer proposal-state))
           (accept (log-flip* (min 0.0 (+ (- new-p old-p) bw/fw))))
           (dummy (reset-store-xrp-draws))
           (score-ratio (+ (- new-p old-p) bw/fw))
           ;;(void (display (list 'score-ratio score-ratio)))
           ) ;;FIXME!! this is to avoid accumulating xrp-draws...
            
      (if accept
          proposal-state
          state))))

;;Larj Kernel
(define (larj-scorer state)
  (apply + (map factor-value (addbox->values (store->factors (mcmc-state->store state))))))

(define (make-larj-kernel proposal-distribution scorer)
  (lambda (state)
    (let* ((ret (proposal-distribution state))
           (bw/fw (first ret))
           (proposal-state (second ret)) 
           (number-of-proposals-made (third ret)) 
           (old-p (scorer state))
           (new-p (scorer proposal-state))
           (accept (log-flip* (min 0.0 (+ (- new-p old-p) bw/fw))))
           (dummy (reset-store-xrp-draws))
           (score-ratio (- new-p old-p))
           ;;(dummy (display (list 'score-ratio score-ratio)))
           ) ;;FIXME!! this is to avoid accumulating xrp-draws...
      (if accept
          (list proposal-state number-of-proposals-made)
          (list state number-of-proposals-made)))))

;; ;; mixture kernel
;; (define (mixture-kernel cdf . kernels )
;;   (lambda (state)
;;     (let ((u (uniform)))
;;       (let loop ((kernels kernels)
;;                  (cdf cdf) )
;;         (if (<= u (car cdf))
;;             ((car kernels) state)
;;             (loop (cdr kernels)
;;                   (cdr cdf) ))))))

;; cycle kernel
(define (cycle-kernel . kernels)
  (lambda (state)
    (fold (lambda (k s) (k s)) state kernels)))

;; repeat a kernel
(define (repeat-kernel steps kernel)
  (apply cycle-kernel (make-list steps kernel)))

(define (basic-repeat-kernel steps nfqp)
  (repeat-kernel steps (make-mh-kernel (lambda (state) (basic-proposal-distribution state nfqp))
                                       mcmc-state->score)))

;;;standard queries
(define (repeated-mcmc-query-core initializer kernel num-samples)
  (let ([init-state (initializer)])
    (mcmc-loop kernel init-state num-samples '())))

(define (repeated-mcmc-query-core-proposal-count initializer kernel num-proposals-to-make)
  (let ([init-state (initializer)])
    (let loop ((kernel kernel)
               (state init-state)
               (samples '())
               (num-proposals-left num-proposals-to-make)
               )
      (if (< num-proposals-left 1)
        (reverse samples)
        (let* (
              (state-and-num-proposals (kernel state))
              (next-state (first state-and-num-proposals))
              (next-num-proposal (second state-and-num-proposals)))
          (loop kernel next-state (pair (mcmc-state->query-value state) samples) (- num-proposals-left next-num-proposal))))))) 

(define (mcmc-loop kernel state samples-left samples)
  (if (< samples-left 1)
      (reverse samples)
      (mcmc-loop kernel (kernel state) (- samples-left 1) (pair (mcmc-state->query-value state) samples))))

(define (mh-query samples lag normal-form-proc)
  (repeated-mcmc-query-core (lambda () (rejection-initializer normal-form-proc))
                            (basic-repeat-kernel lag normal-form-proc)
                            samples))

(define (mh-query/annealed-init temps samples lag rej-steps temps->nfqp)
  (let ([normal-form-proc (apply temps->nfqp (first temps))])
    (repeated-mcmc-query-core (lambda () (annealing-initializer rej-steps temps temps->nfqp))
                              (basic-repeat-kernel lag normal-form-proc)
                              samples)))


;; ----------------------------------------------------------
;; Simple gradient ascent on continuous variables, using AD.

(define (make-gradient-step step-size nfqp)
  (lambda (state)
    (let* ((grad (mcmc-state->gradient state))
           (xrp-draws (mcmc-state->xrp-draws state))
           (xrp-changes (map (lambda (gv) (let ((xrp-draw (first (pull-outof-addbox xrp-draws (first gv)))))
                                       (pair xrp-draw (+ (xrp-draw-value xrp-draw) (* step-size (sigmoid (rest gv)))))))
                             grad))
           (proposal (apply counterfactual-update (pair state (pair nfqp xrp-changes)))))
      (first proposal))))

(define (sigmoid x) (- (/ 1 (+ 1 (exp (- x)))) 0.5))

(define (gradient-ascent steps step-size nfqp)
  (let ((gstep (make-gradient-step step-size nfqp)))
    (let loop ((state (rejection-initializer nfqp))
               (trail '())
               (steps-remaining steps))
      (if (< steps-remaining 1)
          (reverse trail)
          (let ((newstate (gstep state)))
            (loop newstate
                  (pair (mcmc-state->query-value newstate) trail)
                  (- steps-remaining 1)))))))

(define (annealed-gradient-ascent temps:high->low step-size temps->nfqp)
  (let loop ((state (rejection-initializer (apply temps->nfqp (first temps:high->low))))
             (trail '())
             (temps temps:high->low))
    (if (null? temps)
        (reverse trail)
        (let ((newstate ((make-gradient-step step-size (apply temps->nfqp (first temps))) state)))
          (display "ascent loop, temp=")(display (first temps));(display " score=")(display (untapify (mcmc-state->score newstate)))
          (newline)
          (loop newstate
                (pair (mcmc-state->query-value newstate) trail)
                (rest temps))))))


;; --------------------------------------------------------------------
;; Hybrid Monte Carlo

(define (continuous-xrp-draw? xrp-draw)
  (tape? (xrp-draw-value xrp-draw)))

(define (discrete-xrp-draw? xrp-draw)
  (not (continuous-xrp-draw? xrp-draw)))

(define (alist-map proc alist)
  (if (null? alist)
      '()
      (let ([fst (first alist)])
        (pair (proc (first fst)
                    (rest fst))
              (alist-map proc (rest alist))))))

(define (order-values alist order)
  (let ([trie (alist->trie alist)])
    (map (lambda (key) (first (trie-pop trie key)))
         order)))

(define (scalar* sc lst)
  (map (lambda (x) (* sc x)) lst))

(define (list+ a b)
  (map + a b))

(define (list* a b)
  (map * a b))

(define (increment-state state nfqp increments)
  (let* ([xrp-draws (mcmc-state->xrp-draws state)]
         [xrp-changes (alist-map (lambda (addr inc)
                                   (let ([xrp-draw (first (pull-outof-addbox xrp-draws addr))])
                                     (pair xrp-draw (+ (xrp-draw-value xrp-draw) inc))))
                                 increments)])
    (apply counterfactual-update
           (pair state (pair nfqp xrp-changes)))))

;; leapfrog-step
;; 
;; arguments:
;;  nfqp      normal form query proc
;;  q         mcmc-state
;;  a:p       alist of momenta (address -> real)
;;  m-inv     list of reals (address order same as a:p)
;;  dt        real
;; 
;; returns:
;;  q-next    new mcmc-state
;;  a:p-next  alist of new momenta (address -> real)
;;  bw-fw     real
(define (leapfrog-step nfqp q a:p m-inv dt)
  (let* ([addresses (map first a:p)]
         [p (map rest a:p)]
         [q-gradient (order-values (mcmc-state->gradient q) addresses)]
         [p-half (list+ p (scalar* (/ dt 2.0) q-gradient))]
         [increments (scalar* dt (list* m-inv p-half))]
         [q-next/bwfw (increment-state q nfqp (map pair addresses increments))]
         [q-next-gradient (order-values (mcmc-state->gradient (first q-next/bwfw)) addresses)]
         [p-next (list+ p-half (scalar* (/ dt 2.0) q-next-gradient))])
    (list (first q-next/bwfw)
          (map pair addresses p-next)
          (second q-next/bwfw))))

;; FIXME: m-inv should be parameters, or set cleverly.
(define (leapfrog nfqp q a:p dt steps . maybe-bw/fw)
  (let ((bw-fw (if (null? maybe-bw/fw) 0.0 (first maybe-bw/fw)))
        (m-inv (make-list (length a:p) 1.0)))
    (if (= steps 0)
        (list q a:p bw-fw)
        (let ([qn/pn/bwfw+ (leapfrog-step nfqp q a:p m-inv dt)])
          (leapfrog nfqp
                    (first qn/pn/bwfw+)
                    (second qn/pn/bwfw+)
                    dt
                    (- steps 1)
                    (+ bw-fw (third qn/pn/bwfw+)))))))

;; Because the leapfrog integrator is reversible (and volume
;; preserving), the only f/b-probs come from trace-updates.
(define (make-leapfrog-proposal nfqp dt steps)
  (lambda (q-p)
    (let ([q/p/bwfw (leapfrog nfqp (first q-p) (second q-p) dt steps)])
      (list (third q/p/bwfw)
            (list (first q/p/bwfw)
                  (second q/p/bwfw))))))

;; FIXME: inv-mass terms
;; FIXME: term for norm of mass.
(define (hamiltonian-score q-p)
  (let ((q (first q-p))
        (a:p (second q-p)))
    (let ([score (mcmc-state->score q)])
      (if (equal? score minus-infinity)
          minus-infinity
          (+ score (* -0.5 (apply + (map (lambda (x) (expt x 2)) (map rest a:p)))))))))

(define (make-leapfrog-kernel nfqp dt leapfrog-steps)
  (make-mh-kernel (make-leapfrog-proposal nfqp dt leapfrog-steps)
                  hamiltonian-score))

(define (momentum-prior state)
  (fold (lambda (draw momenta)
          (if (continuous-xrp-draw? draw)
              (pair (sample-gaussian 0.0 1.0)
                    momenta)
              momenta))
        '()
        (addbox->values (mcmc-state->xrp-draws state))))

;; Generate appropriate momenta from the momentum prior (this is
;; secretly a kernel on momenta). Then apply leapfrog kernel, return
;; the mcmc state (if we kept the momenta we'd reverse them).
(define (make-hmc-kernel nfqp dt leapfrog-steps)
  (let ([leapfrog-kernel (make-leapfrog-kernel nfqp dt leapfrog-steps)])
    (lambda (state)
      (let ([momenta (momentum-prior state)])
        (first (leapfrog-kernel (list state momenta)))))))

(define (hmc-query num-samples lag dt leapfrog-steps nfqp)
  (repeated-mcmc-query-core
   (lambda () (rejection-initializer nfqp))
   (repeat-kernel lag
                  (cycle-kernel (make-hmc-kernel nfqp dt leapfrog-steps)
                                (make-mh-kernel (lambda (state)
                                                  (selective-proposal-distribution state
                                                                                   nfqp
                                                                                   discrete-xrp-draw?))
                                                mcmc-state->score)))
   num-samples))

(define (hmc-query/annealed-init temps init-step-size num-samples lag dt leapfrog-steps temps->nfqp)
  (let ([nfqp (apply temps->nfqp (first temps))])
    (repeated-mcmc-query-core
     (lambda () (annealing-initializer 1 temps temps->nfqp
                                  (lambda (nfqp) (make-gradient-step init-step-size nfqp)))) ;;do gradient ascent while annealing...
     (repeat-kernel lag
                    (cycle-kernel (make-hmc-kernel nfqp dt leapfrog-steps)
                                  (make-mh-kernel (lambda (state)
                                                    (selective-proposal-distribution state
                                                                                     nfqp
                                                                                     discrete-xrp-draw?))
                                                  mcmc-state->score)))
     
     num-samples)))



;; --------------------------------------------------------------------
;; this is the code for psmc (population sequential monte carlo). this
;; is particle filtering with an mcmc rejuvenation kernel and
;; (eventually) a crossover move.  the sugarred call looks like
;; (psmc-query temp-args temps popsize kernel-iterations
;; ...defs... q-exp c-exp).
(define (psmc-query temps popsize lag temps->nfqp)
  (map mcmc-state->query-value (smc-core temps popsize lag temps->nfqp)))

;;this does the smc without finalizing, so that we can either get the query values or the scores (etc).
(define (smc-core temps popsize lag temps->nfqp)
  (let smc ((temps temps) ;;FIXME: rest temps?
            (population (repeat popsize (lambda () (begin
                                                (reset-store-xrp-draws) ;;FIXME!! this is to avoid accumulating xrp-draws...
                                                (rejection-initializer (apply temps->nfqp (first temps)))))))
            (weights (make-list popsize 0)))

    (let* (;(dummy (display (map mcmc-state->query-value population))) (dummy (display "\n"))
           ;;step forward temps.
           (rets (map (lambda (state) (counterfactual-update state (apply temps->nfqp (first temps)))) population))
           (new-population (map first rets))
           (cd-bw/fw (map second rets))
           (weights (map (lambda (old-weight old-state new-state cd-bw/fw) (+ old-weight
                                                                         (- (mcmc-state->score new-state) (mcmc-state->score old-state))
                                                                         cd-bw/fw))
                         weights
                         population
                         new-population
                         cd-bw/fw))
           
           ;;resample and reset weights (optional).
           (resample-distribution (map exp (log-normalize weights)))
           (collapse? (nan? (first resample-distribution)))
           (new2-population (if collapse?
                                '()
                                (repeat popsize (lambda () (begin
                                                        (reset-store-xrp-draws) ;;FIXME!! this is to avoid accumulating xrp-draws...
                                                        (multinomial new-population resample-distribution))))))
           (weights (make-list popsize 0))
           
           ;;rejuvenate using kernel.
           (kernel (repeat-kernel lag (make-mh-kernel (lambda (state) (basic-proposal-distribution state (apply temps->nfqp (first temps))))
                                                      mcmc-state->score)))
           (new3-population (map kernel new2-population)))

      (begin (map (lambda (x y) (begin (display "  ")(display x)(display "  ")(display y)(display "\n")))
                  (map mcmc-state->query-value new3-population)
                  (map mcmc-state->score new3-population))
             (display "\n")
             ;;loop if there are any temps left.
             (if (or collapse? (null? (rest temps)))
                 new3-population
                 (smc (rest temps) new3-population weights)))))  )


(define (log-sum-exp . log-vals)
  (let* ([max-log-val (apply max log-vals)])
    (if (equal? max-log-val minus-infinity)
        minus-infinity
        (+ (log (exact->inexact (sum (map (lambda (val) (exp (- val max-log-val))) log-vals))))
           max-log-val))))

(define (log-normalize log-scores)
  (let* ([score-sum (apply log-sum-exp log-scores)])
    (map (lambda (score) (- score score-sum)) log-scores)))


;; --------------------------------------------------------------------
;; LARJ
(define (should-do-larj? proposal-state)
  (let ((fpmc (mcmc-state->diff-factors proposal-state)))
    ;;(display (map length fpmc))
    (or (> (length (first fpmc)) 0) (> (length (second fpmc)) 0))
    ))

;; This is implementing Larj-mcmc outer proposals.
;; Larj-mcmc has two types of outer proposals: structural and non-structural.
(define (larj-selective-proposal-distribution state normal-form-proc proposable? num-temps static-proposal)
  (if (addbox-empty? (mcmc-state->xrp-draws state))
      (list 0.0 state) ;; if no xrps have been drawn (eg all randomness in q-e) make trivial proposal. (still have to update..??)
      (let ((proposal-xrps (proposable-xrps state proposable?))) ;;fileter out proposable xrps to proposal-xrps
        (if (null? proposal-xrps)
            (list 0.0 state)
            (let* ((chosen-xrp (uniform-draw* proposal-xrps))
                   (ret1 ((xrp-draw-proposer chosen-xrp) state))
                   (proposed-val (first ret1))
                   (proposal-fw-score (second ret1))
                   (proposal-bw-score (third ret1))
                   (ret2 (counterfactual-update-larj state normal-form-proc (pair chosen-xrp proposed-val))) 
                   (proposal-state (first ret2))
                   (cd-bw/fw (second ret2))
                   (ind-fw (- (log (length proposal-xrps))))
                   (ind-bw (- (log (length (proposable-xrps proposal-state proposable?)))))
                   (structural-change? (should-do-larj? proposal-state))
                   (larj-state-and-correction (if structural-change?
                                                (begin
                                                  ;;(display 'do-larj!!!!!!-did-we-do-perturbation-to-structural-xrp?)
                                                  ;;(display (xrp-draw-structural? chosen-xrp))
                                                  (do-larj-anneal-correction state proposal-state normal-form-proc num-temps static-proposal)
                                                  )
                                                  (list proposal-state 0)))
                   (proposed-larj-state (first larj-state-and-correction))
                   (larj-correction (second larj-state-and-correction))
                   ;;(void (if structural-change? (display (list 'larj-correction larj-correction)) 'null))
                   (num-proposals-to-make (if structural-change? (+ num-temps 1) 1))
                   (final-correction (+ (+ (- proposal-bw-score proposal-fw-score) cd-bw/fw (- ind-bw ind-fw)) larj-correction))
                   ;;(void (if structural-change? (display (list 'final-correction final-correction)) 'null))
                   )
              ;; if structural-change? 1. run static kernel 2. get factor-diffs to compute correction terms
              (list (+ (+ (- proposal-bw-score proposal-fw-score) cd-bw/fw (- ind-bw ind-fw)) larj-correction)
                    proposed-larj-state
                    num-proposals-to-make
                    ))))))

(define (combine-proposable-xrp-draws state1state2 proposable?)
  (let* ((state1 (first state1state2))
         (state2 (second state1state2))
         (combined-xrp-draws (fold (lambda (xrp xrps)
                                     (update-addbox xrps (xrp-draw-address xrp) (lambda (xrp-draw) xrp)))
                                   (copy-addbox (store->xrp-draws (mcmc-state->store state1)))
                                   (addbox->values (store->xrp-draws (mcmc-state->store state2)))))
         (proposable-xrp-draws (filter proposable? (addbox->values combined-xrp-draws))))
    ;;(display 'dimension-of-state1)
    ;;(display (length (filter proposable? (addbox->values (mcmc-state->xrp-draws state1)))))
    ;;(display 'dimension-of-state2)
    ;;(display (length (filter proposable? (addbox->values (mcmc-state->xrp-draws state2)))))
    ;;(display 'dimension-of-the-extended-state-space)
    ;;(display (length proposable-xrp-draws))
    proposable-xrp-draws))

(define (xrp-in-state? xrp state)
  (not (eq? 'none (read-addbox (store->xrp-draws (mcmc-state->store state))
                               (xrp-draw-address xrp)))))

(define STATE_SRC_NONE 0)
(define STATE_SRC_1 1)
(define STATE_SRC_2 2)
(define STATE_SRC_BOTH 3)

(define (which-state-to-perturb-and-new-proposal chosen-xrp state1state2)
  (let* ((state1 (first state1state2))
         (state2 (second state1state2)))
    (cond 
     [(and (xrp-in-state? chosen-xrp state1) (xrp-in-state? chosen-xrp state2)) ;; the chosen-xrp belongs to both state1 and state2
      (list STATE_SRC_BOTH ((xrp-draw-proposer chosen-xrp) state2))] 
     [(xrp-in-state? chosen-xrp state2) ;; the chosen-xrp only belongs to state2
      (list STATE_SRC_2 ((xrp-draw-proposer chosen-xrp) state2))] 
     [(xrp-in-state? chosen-xrp state1) ;; the chosen-xrp only belongs to state1
      (list STATE_SRC_1 ((xrp-draw-proposer chosen-xrp) state1))] 
     [else
      (error chosen-xrp "Error: chosen xrp not in any of the two states!")])))

(define (extended-state-space-selective-proposal-distribution state1state2 normal-form-proc proposable?)
  (let* ((proposal-xrps (combine-proposable-xrp-draws state1state2 proposable?)))
    (if (null? proposal-xrps)
        (list 0.0 state1state2)
        (let* ((state1 (first state1state2))
               (state2 (second state1state2))
               (chosen-xrp (uniform-draw* proposal-xrps))
               (id-state-and-proposed-val (which-state-to-perturb-and-new-proposal chosen-xrp state1state2))
               (id-state-to-perturb (first id-state-and-proposed-val))
               (proposed-val (first (second id-state-and-proposed-val)))
               ;;(void (display 'id-state-to-perturb))
               ;;(void2 (display id-state-to-perturb))
               ;;(void3 (display 'chosen-xrp))
               ;;(void3 (print-single-xrp chosen-xrp))
               ;;(void3 (display 'state1-xrps))
               ;;(void3 (print-mcmc-state-xrps state1))
               ;;(void3 (display 'state2-xrps))
               ;;(void3 (print-mcmc-state-xrps state2))
               ;;(void (display 'run-counterfactual-update-state1))
               (state1* (if (or (= STATE_SRC_BOTH id-state-to-perturb) (= STATE_SRC_1 id-state-to-perturb)) 
                            (first (counterfactual-update state1 normal-form-proc (pair chosen-xrp proposed-val)))
                            state1
                            ))
               ;;(void (display 'run-counterfactual-update-state2))
               (state2* (if (or (= STATE_SRC_BOTH id-state-to-perturb) (= STATE_SRC_2 id-state-to-perturb)) 
                            (first (counterfactual-update state2 normal-form-proc (pair chosen-xrp proposed-val)))
                            state2))
               )
          (list 0 (list state1* state2*))))))

(define (lookup-factor-and-update factors-addbox target-factor)
  (let ((lookup-factor (read-addbox factors-addbox (factor-address target-factor))))
    (if (not (eq? 'none lookup-factor))
        lookup-factor
        target-factor)))

(define (update-f-plus-minus-common-scores state target-f-plus-minus-common)
  (let ([fresh-factors (store->factors (mcmc-state->store state))])
    (map (lambda (factor-instances)
           (map (lambda (factor-instance)
                  (lookup-factor-and-update fresh-factors factor-instance))
                factor-instances))
         target-f-plus-minus-common)))

(define (get-larj-score state1state2 temp up-down-temp)
  (let* ((state1 (first state1state2))
         (state2 (second state1state2))
         (after-update-from-state1-fpmc (update-f-plus-minus-common-scores state1 (store->diff-factors (mcmc-state->store state2))))
         (new-fpmc (update-f-plus-minus-common-scores state2 after-update-from-state1-fpmc))
         (f-plus (first new-fpmc))
         (f-minus (second new-fpmc))
         (f-common (third new-fpmc))
         (f-plus-score-before-annealing (apply + (map factor-value f-plus)))
         (f-minus-score-before-annealing (apply + (map factor-value f-minus)))
         (f-common-must-anneal (apply + (map factor-value (filter factor-must-anneal? f-common))))
         (f-common-no-anneal (apply + (map factor-value (filter (lambda (f)
                                       (or (factor-auto-anneal? f)
                                           (factor-must-not-anneal? f))) f-common))))
         (f-common-score-before-annealing (apply + (map factor-value f-common)))
         (f-plus-score (* f-plus-score-before-annealing (- 1.0 temp)))
         (f-minus-score (* f-minus-score-before-annealing temp))
         (f-common-score (+ (* f-common-must-anneal up-down-temp) f-common-no-anneal)))
    ;;(display 'f-plus-minus-common)
    ;;(display (list (length f-plus) (length f-minus) (length f-common)))
    ;;(display (list 'score-before-annealing 'temp temp))
    ;;(display (list f-plus-score-before-annealing f-minus-score-before-annealing f-common-score-before-annealing))
    ;;(display 'score-after-annealing)
    ;;(display (list f-plus-score f-minus-score f-common-score))
    (+ f-plus-score f-minus-score f-common-score)))

(define (do-larj-anneal-correction original-state jumped-state normal-form-proc num-temps static-proposal)
  (let loop ((total-correction 0)
             (temp-list 
               (begin 
                 ;;(display (interp-range-pow 1.0 0.0 num-temps 1))
                 (interp-range-pow 1.0 0.0 num-temps 1) 
                 ))
             (up-down-temp-list
               (if (even? num-temps)
                 (append
                   (interp-range-pow 1.0 0.0 (/ num-temps 2) 1)
                   (interp-range-pow 0.0 1.0 (/ num-temps 2) 1))
                 (append
                   (interp-range-pow 1.0 0.0 (+ 1 (/ num-temps 2)) 1)
                   (cdr (interp-range-pow 0.0 1.0 (+ 1 (/ num-temps 2)) 1)))))
             (curr-state (list original-state jumped-state)))
    (if (= temp-list '())
      (list (second curr-state) total-correction)
      (let* ((bw/fw-and-next-state (static-proposal curr-state))
             (bw/fw (first bw/fw-and-next-state))
             (next-state (second bw/fw-and-next-state))
             (curr-score (get-larj-score curr-state (car temp-list) (car up-down-temp-list)))
             (next-score (get-larj-score next-state (car temp-list) (car up-down-temp-list)))
             (local-alpha (- next-score curr-score))
             (accept (log-flip* (min 0.0 (+ local-alpha bw/fw))))
             ;;(void (display (list 'local-alpha local-alpha 'accept accept)))
             )
        (if accept
          (loop (+ total-correction (- local-alpha)) (cdr temp-list) (cdr up-down-temp-list) next-state) ;;if accept, accumulate alpha
          (loop total-correction (cdr temp-list) (cdr up-down-temp-list) curr-state))))))

(define (non-structural-proposal-distribution state normal-form-proc)
  (selective-proposal-distribution state
                                   normal-form-proc
                                   (lambda (xrp-draw) (not (xrp-draw-structural? xrp-draw)))))

(define (extended-state-space-proposal-distribution state1state2 normal-form-proc)
  (extended-state-space-selective-proposal-distribution state1state2
                                                        normal-form-proc
                                                        (lambda (xrp-draw) (not (xrp-draw-structural? xrp-draw)))))

(define (larj-proposal-distribution state normal-form-proc num-temps static-proposal)
  (larj-selective-proposal-distribution state
                                        normal-form-proc
                                        ;;(lambda (xrp-draw) true) num-temps static-proposal))
                                        xrp-draw-structural? num-temps static-proposal))

(define (non-structural-kernel steps nfqp)
  (repeat-kernel steps 
                 (make-mh-kernel 
                  (lambda (state) (non-structural-proposal-distribution state nfqp))
                  mcmc-state->score)))

;; larj kernel
;; The static-proposal is used for performing proposals in the annealing stage. 
;; The extended-state-space, state1state2, is a list of two states corresponding to the state space before and after the jump.
;; We use the extended-state-space representation it lets us to make proposals to variables to be removed more easily. 
;; In addition, we need to calculate the scores of f-plus, f-minus, and f-common.
(define (larj-kernel num-temps steps nfqp)
  (let ((static-proposal (lambda (state1state2) (extended-state-space-proposal-distribution state1state2 nfqp))))
    (repeat-kernel 
     steps 
     (make-mh-kernel
      (lambda (state) (larj-proposal-distribution state nfqp num-temps static-proposal))
      mcmc-state->score))))

(define (larj-kernel-proposal-count num-temps steps nfqp)
  (let ((static-proposal (lambda (state1state2) (extended-state-space-proposal-distribution state1state2 nfqp))))
     (make-larj-kernel
      (lambda (state) (larj-proposal-distribution state nfqp num-temps static-proposal))
      mcmc-state->score)))

(define (non-structural-mh-query samples lag normal-form-proc)
  (repeated-mcmc-query-core (lambda () (rejection-initializer normal-form-proc))
                            (non-structural-kernel lag normal-form-proc)
                            samples))

(define (larj-mh-query samples lag num-temps normal-form-proc)
  (repeated-mcmc-query-core (lambda () (rejection-initializer normal-form-proc))  ;; initializer
                            (larj-kernel num-temps lag normal-form-proc)     ;; kernel
                            samples))                                        ;; num samples to show

(define (larj-mh-query-proposal-count num-proposals-to-make lag num-temps normal-form-proc)
  (repeated-mcmc-query-core-proposal-count (lambda () (rejection-initializer normal-form-proc))  ;; initializer
                            (larj-kernel-proposal-count num-temps lag normal-form-proc)     ;; kernel
                            num-proposals-to-make))                                        ;; num samples to show
