;; Adapted from
;; http://projects.csail.mit.edu/church/wiki/Mixture_and_Non-Parametric_Models
;;
;; Once we have provenance tracking, use local factors.

(define prob-factor
  (make-factor
   (lambda (p) (let ([logp (* 10 (log p))])
            (display (exp logp))
            logp))))

(define (fraction-equal? a b)
  (/ (length (filter (lambda (x) x) (map equal? a b)))
     (max (length a) (length b))))

(define (factor-lst-equal? a b)
  (cond [(and (null? a) (null? b)) true]
        [(or (null? a) (null? b)) false]
        [(and (list? a) (list? b))
         (begin (prob-factor (fraction-equal? a b))
                true)]
        [else false]))

(define (bool->int obj)
  (if (list? obj)
      (map bool->int obj)
      (if obj 1 0)))

(define (print-bool-matrix matrix)
  (for-each (lambda (row)
              (display row))
            (bool->int matrix)))

(define (generate-square-matrix proc objects)
  (map (lambda (obj1)
         (map (lambda (obj2)
                (proc obj1 obj2))
              objects))
       objects))

(define (generate-irm-data num-objects)
  (let* ([class-distribution (DPmemS 1.0 gensym)]
         [object->class (mem (lambda (object) (class-distribution)))]
         [classes->parameters (mem (lambda (class1 class2) (first (beta 0.5 0.5))))]
         [related (lambda (obj1 obj2) (flip (classes->parameters (object->class obj1)
                                                            (object->class obj2))))]
         [objects (iota num-objects)])
    (let ([matrix (generate-square-matrix related objects)]
          [classes (map object->class objects)])
      (list matrix classes))))

(define (generate-extreme-irm-data num-objects)
  (let* ([object->class (lambda (object) (if (> object (/ num-objects 2)) 'class1 'class2))]
         [classes->parameters (mem (lambda (class1 class2) (if (eq? class1 class2) .95 .05)))]
         [related (lambda (obj1 obj2) (flip (classes->parameters (object->class obj1)
                                                            (object->class obj2))))]
         [objects (iota num-objects)])
    (let ([matrix (generate-square-matrix related objects)]
          [classes (map object->class objects)])
      (list matrix classes))))

(define data->matrix first)

(define data->classes second)

(define (classes->equivalences classes)
  (map (lambda (c1) 
         (map (lambda (c2)
                (eq? c1 c2))
              classes))
       classes))

(define (display-irm-sample)
  (let* ([matrix+classes (generate-irm-data 10)]
         [matrix (first matrix+classes)]
         [classes (second matrix+classes)])
    (print-bool-matrix matrix)))

(define (matrix-fraction-equal? m1 m2)
  (fraction-equal? (apply append m1)
                   (apply append m2)))

(define (score-classes true-classes classes)
  (exact->inexact
   (matrix-fraction-equal? (classes->equivalences true-classes)
                           (classes->equivalences classes))))

(define (baseline-score num-objects)
  (mean
   (repeat 100
           (lambda ()
             (let ([s1 (generate-irm-data num-objects)]
                   [s2 (generate-irm-data num-objects)])
               (score-classes (data->classes s1)
                              (data->classes s2)))))))

(define bool-softeq
  (make-factor
   (lambda (a b)
     (if (equal? a b)
         1.0
         (log .5)))))

(define (matrix-equal-factor m1 m2)
  (map (lambda (r1 r2)
         (map (lambda (x1 x2)
                (bool-softeq x1 x2))
              r1
              r2))
       m1
       m2))

  
(define (irm-mh-inference num-samples lag num-objects observation-matrix true-classes)
  (mh-query 
   num-samples lag

   (define objects (iota num-objects))
   
   (define class-distribution (DPmemS 1.0 gensym))
   
   (define object->class
     (mem (lambda (object) (class-distribution))))
   
   (define classes->parameters
     (mem (lambda (class1 class2) (first (beta 0.5 0.5)))))
   
   (define (related object1 object2)
     (flip (classes->parameters (object->class object1) (object->class object2))))

   (score-classes true-classes (map object->class objects))

   (begin
     (matrix-equal-factor observation-matrix
                          (generate-square-matrix related objects))
     true)))


(define (irm-rejection-inference num-samples num-objects observation-matrix true-classes)
  (repeat
   num-samples
   (lambda ()
     (factor-rejection-query

      (define objects (iota num-objects))
      
      (define class-distribution (DPmemS 1.0 gensym))
      
      (define object->class
        (mem (lambda (object) (class-distribution))))
      
      (define classes->parameters
        (mem (lambda (class1 class2) (first (beta 0.5 0.5)))))
      
      (define (related object1 object2)
        (flip (classes->parameters (object->class object1) (object->class object2))))

      (score-classes true-classes (map object->class objects))

      (begin
        (matrix-equal-factor observation-matrix
                             (generate-square-matrix related objects))
        true)))))


(define (irm-larj-inference num-samples lag anneal-steps num-objects observation-matrix true-classes)
  (larj-mh-query-proposal-count
   num-samples lag anneal-steps

   (define objects (iota num-objects))
   
   (define class-distribution (DPmemS 1.0 gensym))
   
   (define object->class
     (mem (lambda (object) (class-distribution))))
   
   (define classes->parameters
     (mem (lambda (class1 class2) (first (beta 0.5 0.5)))))
   
   (define (related object1 object2)
     (flip (classes->parameters (object->class object1) (object->class object2))))

   (score-classes true-classes (map object->class objects))

   (begin
     (matrix-equal-factor observation-matrix
                          (generate-square-matrix related objects))
     true)))


(let* ([num-objects 6]
       [num-steps 5000]
       [anneal-steps 20]
       [data (generate-irm-data num-objects)])
  (display "baseline score:")
  (display (baseline-score num-objects))
  ;; (let ([mh-scores (irm-mh-inference (/ num-steps anneal-steps) anneal-steps
  ;;                                    num-objects
  ;;                                    (data->matrix data)
  ;;                                    (data->classes data))])
  ;;   ;; (display "mh-scores:")
  ;;   ;; (display mh-scores)
  ;;   (display (mean mh-scores))
  ;;   (let ([larj-scores (irm-larj-inference num-steps 1
  ;;                                          anneal-steps
  ;;                                          num-objects
  ;;                                          (data->matrix data)
  ;;                                          (data->classes data))])
  ;;     ;; (display "larj-scores:")
  ;;     ;; (display larj-scores)
  ;;     (display (mean larj-scores))
      (let ([rejection-scores (irm-rejection-inference 10
                                                       num-objects
                                                       (data->matrix data)
                                                       (data->classes data))])
        (display (mean rejection-scores))
        'done))