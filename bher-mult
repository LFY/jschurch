#!/usr/bin/python
import os, sys, itertools, multiprocessing
from subprocess import Popen
from external import optfunc
from os.path import abspath, dirname
from datetime import datetime

def vprint(s, verbose):
    if verbose:
        print
        print s

def call(cmd, verbose=False, allow_fail=False):
    if verbose:
        print cmd
    p = Popen(cmd, shell=True)
    p.communicate()
    status = p.returncode
    if status != 0 and not allow_fail:
        print "command failed:\n%s" % cmd
        exit()
    else:
        return status

def parse_dimension(str):
	key, vals = str.split(":")
	vals = vals.split(",")
	return map(lambda x: {key: x}, vals)

def parse_params(params):
    if params == "":
        return [{None: None}]
    else:
        dimensions = params.split(" ")
        return map(parse_dimension, dimensions)

def compute(pair):
    exec_str, verbose = pair
    pre = datetime.now()
    return_str =  call(exec_str, verbose)
    post = datetime.now()
    delta = post-pre
    seconds = delta.seconds + delta.microseconds/1000000.0
    return seconds

compilers = {
    "vicare" : {
        #"header" : "scheme-compilers/header-vicare.sc",
        #"trailer" : "scheme-compilers/trailer-vicare.sc",
        "template" : "scheme-compilers/vicare-template.sc",
        "extension" : ".ss",
        "runnable" : True },
    "biwa" : {
        #"header" : "scheme-compilers/header-biwa.sc",
        #"trailer" : "scheme-compilers/trailer-biwa.sc",
        "template" : "scheme-compilers/biwa-template.sc",
        "extension" : ".html",
        "runnable" : False },
    "scheme2js" : {
        #"header" : "scheme-compilers/header-scheme2js.sc",
        #"trailer" : "scheme-compilers/trailer-scheme2js.sc",
        "template" : "scheme-compilers/scheme2js-template.sc",
        "extension" : ".sc",
        "runnable" : False },
    }

@optfunc.main
@optfunc.arghelp('verbose', 'display all executed commands')
@optfunc.arghelp('debug', 'run all ikarus commands in debug mode')
@optfunc.arghelp('pretty', 'keep & pretty-print compiled file')
@optfunc.arghelp('ext', 'definitions to be included in header of compiled file')
@optfunc.arghelp('time', 'record the time it takes for the compiled file to run')
@optfunc.arghelp('set', 'run church file with multiple parameter settings')
@optfunc.arghelp('keep', 'do not delete compiled file')
@optfunc.arghelp('numcores', 'number of cores to run parallel jobs on')
@optfunc.arghelp('compiler', 'compiler to use (available: vicare, biwa, scheme2js)')
def main(file, verbose=False, debug=False, keep=False, pretty=False, time=False, norun=False, ext="", set="", compiler="vicare",numcores=None):
    """Usage: %prog <file> [options]

Examples:

  bher foo.church -dp
  Compile & run foo.church in debug mode, pretty-print compiled file
  to foo.church.ss.

  bher foo.church -v -e defs.ss
  Compile & run foo.church including definitions from defs.ss, print
  all commands used.

  bher foo.church -t -s samples:10,100,1000
  Compile & run foo.church three times, replacing %(samples)s in
  foo.church with 10, 100, and 1000 respectively. Print out runtime
  for each setting.

  bher foo.church -c biwa
  Compile foo.church to html/js.
"""
    if pretty: keep = True
    params = parse_params(set)
    bher_path = abspath(dirname(sys.argv[0]))
    settings = {
        "bher_path" : bher_path,
        "in_path" : abspath(file),
        ##"header_path" : abspath(os.path.join(bher_path, compilers[compiler]["header"])),
        ##"trailer_path" : abspath(os.path.join(bher_path, compilers[compiler]["trailer"])),
        "template_path" : abspath(os.path.join(bher_path, compilers[compiler]["template"])),
        "compiler" : abspath(os.path.join(bher_path, "church/church-compiler.ss")),
        "debug" : debug and "--debug" or "",
        "pretty" : pretty and "T" or "F",
        "ext" : ext and abspath(ext) or ""
    }
    
    compute_space = []
    
    for (i,dicts) in enumerate(itertools.product(*params)):
        # combine the "unitary" dictionaries
        dimensionvalues = reduce(lambda x,y: dict(x.items() + y.items()), dicts)

        if dicts[0]:
            vprint("Pre-processing: %s" % dimensionvalues,verbose) 
            settings["out_path"] = abspath(file) + "." + str(i) + ".ss"
        else:
            settings["out_path"] = abspath(file) + ".ss"

        vprint("removing old compilation files (if existent)", verbose)
        call("rm -f '%(out_path)s'" % settings, verbose, allow_fail=True)
        call("rm -f '%(out_path)s.tmp'" % settings, verbose, allow_fail=True)
        call("rm -f '%(in_path)s.tmp'" % settings, verbose, allow_fail=True)

        vprint("processing input file", verbose)
        if dicts[0]:
            code = open(file).read() % dimensionvalues
            f = open(file + ".tmp", "w")
            f.write(code)
            f.close()
        else:
            call("cp '%(in_path)s' '%(in_path)s.tmp'" % settings, verbose)

        vprint("compiling church->scheme", verbose)
        call(("cd '%(bher_path)s' && vicare %(debug)s --r6rs-script '%(compiler)s' " +
              "'%(in_path)s.tmp' '%(out_path)s.tmp' '%(ext)s' %(pretty)s") % settings, verbose)
        settings["churchprogram"] = open("%(out_path)s.tmp" % settings).read()
        call("rm -f '%(in_path)s.tmp'" % settings, verbose, allow_fail=True)
        call("rm -f '%(out_path)s.tmp'" % settings, verbose, allow_fail=True)

        ## vprint("adding compiler-specific header & footer", verbose)
        ## call(("cat '%(header_path)s' '%(out_path)s.tmp' '%(trailer_path)s' " +
        ##       "> '%(out_path)s'") % settings, verbose)
        ## call("rm -f '%(out_path)s.tmp'" % settings, verbose, allow_fail=True)

        vprint("wrapping with compiler-specific template", verbose)
        template = open(settings["template_path"]).read()
        open(settings["out_path"], "w").write(template % settings)
        
        compute_space.append(["vicare %(debug)s --r6rs-script '%(out_path)s'" % settings, verbose])
        
    if __name__ == '__main__':
        if not (numcores == None):
            numcores = int(numcores)
        pool = multiprocessing.Pool(numcores)
        results = []
        r = pool.map_async(compute, compute_space, callback=results.append)
        r.wait() # Wait on the results
        print results